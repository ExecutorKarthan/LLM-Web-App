def draw_grid(size, box_size, path, branch_path):
    """Draws a grid with a path."""

    screen = turtle.Screen()
    screen.setup(width=size * box_size + 50, height=size * box_size + 50)
    screen.bgcolor("white")
    turtle_instance = turtle.Turtle()
    turtle_instance.speed(0)  # Fastest speed
    turtle_instance.hideturtle()
    turtle_instance.penup()

    for row in range(size):
        for col in range(size):
            x = (col - size // 2) * box_size
            y = (size // 2 - row) * box_size
            turtle_instance.goto(x, y)
            turtle_instance.pendown()

            # Determine color based on location and path
            if (row, col) == (0, 0):
                color = "green"  # Top-left corner
            elif (row, col) == (size-1, size-1):
                 color = "gold" # Bottom right corner
            elif (row, col) == (1, 4):
                color = "silver"
            elif (row, col) == (6, 5):
                color = "black"
            elif (row, col) in path:
                color = "white"  # Path color
            elif (row, col) in branch_path and (row, col) != branch_path[-1]:
                color = "white" # Branch Path color
            else:
                color = "blue"  # Default color

            turtle_instance.fillcolor(color)
            turtle_instance.begin_fill()
            for _ in range(4):
                turtle_instance.forward(box_size)
                turtle_instance.left(90)
            turtle_instance.end_fill()
            turtle_instance.penup()


def navigate_path(turtle_instance, grid_size, box_size, path, branch_path):
    """Navigates the turtle along the combined path to the gold square."""

    turtle_instance.speed(3)  # adjust turtle speed. 1 is slowest, 10 is fastest. 0 is fastest with no animation
    turtle_instance.shape("turtle")  # Set turtle shape
    turtle_instance.color("black")
    turtle_instance.penup()

    silver_found = False #track wether the silver square has been found or not

    def grid_to_screen(row, col):
        """Converts grid coordinates to screen coordinates."""
        x = (col - grid_size / 2) * box_size + box_size / 2
        y = 20 + (grid_size / 2 - row) * box_size - box_size / 2
        return x, y

    def is_valid_move(row, col, path, branch_path, grid_size, silver_found):
        """Checks if a move is valid (within bounds and not on a blue square)."""
        if 0 <= row < grid_size and 0 <= col < grid_size:
            if (row, col) in path or (row, col) in branch_path or (row,col) == (grid_size-1, grid_size-1):
                return True
            elif (row, col) == (6,5) and silver_found: #allow turtle to walk through the black square if it has found silver
                return True
        return False

    def solve_maze(row, col, current_path, visited, silver_found):
        """Recursive function to solve the maze."""
        silver_found #allows the solve_maze function to change the value of the silver_found variable in the parent scope

        if (row, col) == (grid_size - 1, grid_size - 1):  # Reached the gold square
            return current_path

        # Possible moves (up, down, left, right)
        moves = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]

        for new_row, new_col in moves:
            if (new_row, new_col) == (1, 4) and not silver_found: #found the silver square
                silver_found = True
                turtle_instance.color("orange") #turtle turns orange upon touching silver
                print("Silver square found!")

            if is_valid_move(new_row, new_col, path, branch_path, grid_size, silver_found) and (new_row, new_col) not in visited:
                new_path = current_path + [(new_row, new_col)]
                new_visited = visited.copy()
                new_visited.add((new_row, new_col))

                #move the turtle as it searches (before recursion)
                x, y = grid_to_screen(new_row, new_col)
                turtle_instance.goto(x, y)
                screen = turtle.Screen() #screen must be refreshed within the for loop or it will not update. 
                screen.update() #force screen to update


                solution = solve_maze(new_row, new_col, new_path, new_visited, silver_found)
                if solution:
                    return solution
                else:
                    #backtrack (move turtle back to previous position if that path is a dead end.)
                    x, y = grid_to_screen(row, col)
                    turtle_instance.goto(x, y)
                    screen = turtle.Screen() #screen must be refreshed within the for loop or it will not update. 
                    screen.update()



        return None  # No solution found from this path

    # Initial position (green square)
    start_row, start_col = 0, 0
    x, y = grid_to_screen(start_row, start_col)
    turtle_instance.goto(x-2, y)
    turtle_instance.up()

    # Solve the maze
    initial_path = [(start_row, start_col)]
    visited = {(start_row, start_col)}

    solution_path = solve_maze(start_row, start_col, initial_path, visited, silver_found)

    if solution_path:
        # Navigate the turtle along the solution path
        print("Solution found!")
        return
    else:
        print("No solution found!")
        return


# Example usage:
grid_size = 10
box_size = 20

path = [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (3, 2), (3, 3), (4, 3), (4, 4), (5, 4), (5, 5), (6, 5), (7, 5), (7, 6), (8, 6), (8, 7), (9, 7), (9, 8), (9, 9)]

branch_path = [(3, 3), (3, 4), (3, 5), (2, 5), (1, 5), (1, 4), (0, 4)]

# Draw the grid with the path
draw_grid(grid_size, box_size, path, branch_path)

# Create a turtle instance for navigation
nav_turtle = turtle.Turtle()
nav_turtle.penup()

# Navigate the path
navigate_path(nav_turtle, grid_size, box_size, path, branch_path)