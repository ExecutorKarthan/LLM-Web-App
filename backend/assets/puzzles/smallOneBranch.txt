def draw_grid(size, box_size, path, branch_path):
    """Draws a grid with a path."""

    screen = turtle.Screen()
    screen.setup(width=size * box_size + 50, height=size * box_size + 50)
    screen.bgcolor("white")
    turtle_instance = turtle.Turtle()
    turtle_instance.speed(0)  # Fastest speed
    turtle_instance.hideturtle()
    turtle_instance.penup()

    for row in range(size):
        for col in range(size):
            x = (col - size // 2) * box_size
            y = (size // 2 - row) * box_size
            turtle_instance.goto(x, y)
            turtle_instance.pendown()

            # Determine color based on location and path
            if (row, col) == (0, 0):
                color = "green"  # Top-left corner
            elif (row, col) == (size-1, size-1):
                 color = "gold" # Bottom right corner
            elif (row, col) in path:
                color = "white"  # Path color
            elif (row, col) in branch_path and (row, col) != branch_path[-1]:
                color = "white" # Branch Path color
            else:
                color = "blue"  # Default color

            turtle_instance.fillcolor(color)
            turtle_instance.begin_fill()
            for _ in range(4):
                turtle_instance.forward(box_size)
                turtle_instance.left(90)
            turtle_instance.end_fill()
            turtle_instance.penup()

def generate_branch_path(path, grid_size, min_length=5):
    """Generates a random branch path."""
    if not path:
        return []

    # Choose a random point from the existing path to branch off from
    branch_start_index = random.randint(0, len(path) - 1)
    branch_start = path[branch_start_index]

    branch_path = [branch_start]
    current_row, current_col = branch_start

    while len(branch_path) < min_length:
        possible_moves = []
        if current_row > 0 and (current_row - 1, current_col) not in branch_path and (current_row - 1, current_col) not in path:
            possible_moves.append((current_row - 1, current_col))
        if current_row < grid_size - 1 and (current_row + 1, current_col) not in branch_path and (current_row + 1, current_col) not in path:
            possible_moves.append((current_row + 1, current_col))
        if current_col > 0 and (current_row, current_col - 1) not in branch_path and (current_row, current_col - 1) not in path:
            possible_moves.append((current_row, current_col - 1))
        if current_col < grid_size - 1 and (current_row, current_col + 1) not in branch_path and (current_row, current_col + 1) not in path:
            possible_moves.append((current_row, current_col + 1))

        if not possible_moves:
            break  # No valid moves, stop the branch

        next_row, next_col = random.choice(possible_moves)
        branch_path.append((next_row, next_col))
        current_row, current_col = next_row, next_col

    return branch_path

def move_turtle_along_path(path, box_size, grid_size):
    """Moves a turtle along a given path."""

    screen = turtle.Screen()
    screen.setup(width=grid_size * box_size + 50, height=grid_size * box_size + 50)
    turtle_instance = turtle.Turtle()
    turtle_instance.speed(1)
    turtle_instance.shape("turtle")
    turtle_instance.color("red")  # Change turtle color to red
    turtle_instance.penup()
    turtle_instance.showturtle()

    for row, col in path:
        x = (col - grid_size // 2) * box_size + box_size / 2
        y = (grid_size // 2 - row) * box_size - box_size / 2
        turtle_instance.goto(x, y)
        # Delay for a short duration
        turtle.delay(100) # Delay is in milliseconds.
        
grid_size = 5
box_size = 20

path = [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (4, 3), (4, 4)]

branch_path = [(0, 1), (0, 2), (0, 3), (1, 3), (1, 4)]

# Draw the grid with the path
draw_grid(grid_size, box_size, path, branch_path)

